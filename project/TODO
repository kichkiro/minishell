TODO List

Builtins:

[x] cd
- [x] access
- [x] all options
- [x] exit status
- [x] all options with exit status

[x] pwd
- [x] exit status

[x] echo
- [x] -n
- [x] exit status

[x] env
- [x] exit status

[x] export
- [x] no arguments
- [x] export var=value
- [x] export var
- [x] no arguments and var=NULL
- [x] export var=value var2=value2
- [x] exit status
- [x] no arguments and no variables

[x] exit / Ctrl + D

[x] unset
- [x] no arguments
- [x] exit status
- [x] no variables
- [x] no arguments and no variables


Functions:
[V] invalid_prompt
[ ] variable_assignment

Documentation:
[V] invalid_prompt
[ ] variable_assignment
[V] variable_expand
[V] lst functions

Tester:
[V] Commands
[V] Exit status



BUG --->

cat < file1 | cat > file2 < file 1 | wc -l
minishell: file: No such file or directory

# settare l'exit_status dopo questo errore altrimenti non funziona.

--->



# cat < file1 | cat > file2
cat < file1 | echo 1 > file2 | wc -l (non funziona)

cat < file1 | cat > file2 | wc -l (funziona)

# Debug:
# Salva fd input del terminale.
# Aggiunge new_fd e prev_fd a fd_handler().
# Sostituisce fd input con fd file1.
# Pipe salva fd precedente, quindi fd input di file1.
# Crea un processo figlio e sostituisce fd output con fd_pipe[1].
# Esegue il comando, quindi scrive l'output di "cat < file1" in pipe.
# Termina il processo figlio.
# Sostituisce fd input con fd_pipe[0], quindi sostituisce l'input di file1.
# ---> Quindi ora abbiamo due ridirezioni di input, una da file1 e una da pipe.
# ///// Ora si chiude l'ultimo fd. questo e' un problema in quanto si va a chiudere pipe. invece ora proviamo achiudere tutti gli fd alla fine


cat > file2 < file1 | wc -l (non funziona)
